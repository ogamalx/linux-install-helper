"""Windows helper to stage Linux boot from NTFS.

This script is designed to be frozen with PyInstaller into an exe. It
focuses on the setup tasks that can be performed from an administrative
PowerShell or Command Prompt on Windows 10:

* Download a Linux ISO into a working directory on an NTFS partition.
* Generate a minimal ``menu.lst`` for grub4dos to loop-boot that ISO.
* Generate a ``.bat`` script that wires a grub4dos boot entry into BCD.

The script does not attempt to install a bootloader automatically.
Instead it produces the files and commands required so you can review
and run them with elevated privileges.
"""
from __future__ import annotations

import argparse
import hashlib
import sys
import textwrap
import urllib.request
from pathlib import Path

DEFAULT_ISO_URL = (
    "https://cdimage.debian.org/debian-cd/current/amd64/iso-dvd/debian-12.5.0-amd64-DVD-1.iso"
)
DEFAULT_ISO_NAME = "linux.iso"
DEFAULT_WORKDIR = Path.home() / "linux-install-helper"

MENU_TEMPLATE = """# Auto-generated by install_helper.py
# Copy this file to the root of the NTFS partition that hosts your ISO.
# Ensure grldr and grldr.mbr from grub4dos are also present in the same partition.

color blue/green yellow/black white/blue white/black

# Loop-boot the downloaded ISO. Adjust kernel parameters as needed.
title Boot Linux installer from ISO
find --set-root /{iso_name}
map /{iso_name} (hd32)
map --hook
chainloader (hd32)
boot
"""

BCD_BATCH_TEMPLATE = """@echo off
REM Auto-generated by install_helper.py
REM Run this from an elevated Command Prompt.

set WORKPART=%SystemDrive%
if NOT "%~1"=="" set WORKPART=%~1

bcdedit /create /d "Linux via grub4dos" /application BOOTSECTOR > tmp_guid.txt
for /f "tokens=1,2" %%a in (tmp_guid.txt) do if "%%a"=="The" set GUID=%%b
if "%GUID%"=="" for /f "tokens=2" %%a in (tmp_guid.txt) do set GUID=%%a

echo Created entry: %GUID%

bcdedit /set %GUID% device partition=%WORKPART%
bcdedit /set %GUID% path \grldr.mbr
bcdedit /displayorder %GUID% /addlast
bcdedit /timeout 5

del tmp_guid.txt

echo Done. Ensure grldr.mbr and menu.lst exist at %WORKPART%\
"""


def download(url: str, dest: Path) -> None:
    dest.parent.mkdir(parents=True, exist_ok=True)
    with urllib.request.urlopen(url) as response, open(dest, "wb") as fh:
        while True:
            chunk = response.read(64 * 1024)
            if not chunk:
                break
            fh.write(chunk)


def sha256sum(path: Path) -> str:
    h = hashlib.sha256()
    with open(path, "rb") as fh:
        for chunk in iter(lambda: fh.read(128 * 1024), b""):
            h.update(chunk)
    return h.hexdigest()


def _require_twrp_hash(iso_name: str, expected_sha256: str | None) -> None:
    if "twrp" in iso_name.lower() and not expected_sha256:
        print(
            "TWRP images require --expected-sha256 so the download can be verified. "
            f"Pass the published SHA256 for {iso_name}."
        )
        sys.exit(1)


def write_menu(workdir: Path, iso_name: str) -> Path:
    path = workdir / "menu.lst"
    path.write_text(MENU_TEMPLATE.format(iso_name=iso_name), encoding="utf-8")
    return path


def write_bcd_batch(workdir: Path) -> Path:
    path = workdir / "install-grub4dos.bat"
    path.write_text(BCD_BATCH_TEMPLATE, encoding="utf-8")
    return path


def action_init(args: argparse.Namespace) -> None:
    workdir = Path(args.workdir).expanduser()
    workdir.mkdir(parents=True, exist_ok=True)
    print(f"Initialized work directory at {workdir}")


def action_download_iso(args: argparse.Namespace) -> None:
    workdir = Path(args.workdir).expanduser()
    workdir.mkdir(parents=True, exist_ok=True)
    dest = workdir / args.iso_name
    if dest.exists() and not args.force:
        print(f"ISO already exists at {dest}. Use --force to overwrite.")
        return
    _require_twrp_hash(args.iso_name, args.expected_sha256)
    print(f"Downloading {args.url} -> {dest}")
    download(args.url, dest)
    print(f"Download complete. SHA256: {sha256sum(dest)}")


def action_verify_iso(args: argparse.Namespace) -> None:
    workdir = Path(args.workdir).expanduser()
    iso_path = workdir / args.iso_name
    if not iso_path.exists():
        print(f"ISO not found at {iso_path}")
        return

    _require_twrp_hash(args.iso_name, args.expected_sha256)
    digest = sha256sum(iso_path)
    print(f"SHA256 for {iso_path}: {digest}")
    if args.expected_sha256:
        if digest.lower() == args.expected_sha256.lower():
            print("Hash matches expected SHA-256.")
        else:
            print("Hash DOES NOT match expected SHA-256!")


def action_generate_menu(args: argparse.Namespace) -> None:
    workdir = Path(args.workdir).expanduser()
    workdir.mkdir(parents=True, exist_ok=True)
    path = write_menu(workdir, args.iso_name)
    print(f"menu.lst written to {path}")


def action_generate_bcd(args: argparse.Namespace) -> None:
    workdir = Path(args.workdir).expanduser()
    workdir.mkdir(parents=True, exist_ok=True)
    path = write_bcd_batch(workdir)
    print(f"BCD install script written to {path}")


def action_full_setup(args: argparse.Namespace) -> None:
    workdir = Path(args.workdir).expanduser()
    action_init(args)
    args.url = args.url or DEFAULT_ISO_URL
    action_download_iso(args)
    action_generate_menu(args)
    action_generate_bcd(args)
    print(
        textwrap.dedent(
            f"""
            Next steps:
            1) Copy grldr and grldr.mbr from grub4dos into {workdir}.
            2) Review {workdir / 'menu.lst'} and adjust kernel parameters as needed.
            3) Run the generated install-grub4dos.bat from an elevated Command Prompt.
            4) Reboot and select the 'Linux via grub4dos' entry to start the installer.
            """
        ).strip()
    )


def build_parser() -> argparse.ArgumentParser:
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument(
        "--workdir",
        default=str(DEFAULT_WORKDIR),
        help="Directory on NTFS where ISO, menu.lst, and scripts should live.",
    )
    parser.add_argument("--iso-name", default=DEFAULT_ISO_NAME, help="Filename for the ISO")
    parser.add_argument("--url", default=DEFAULT_ISO_URL, help="Linux ISO URL")
    parser.add_argument(
        "--expected-sha256",
        help="Expected SHA-256 hash for the ISO (required for TWRP-named files).",
    )
    parser.add_argument("--force", action="store_true", help="Overwrite existing ISO")

    sub = parser.add_subparsers(dest="command", required=True)
    sub.add_parser("init", help="Create the working directory").set_defaults(
        func=action_init
    )
    sub.add_parser("download-iso", help="Download the ISO").set_defaults(
        func=action_download_iso
    )
    sub.add_parser("generate-menu", help="Write grub4dos menu.lst").set_defaults(
        func=action_generate_menu
    )
    sub.add_parser("generate-bcd", help="Write BCD wiring batch script").set_defaults(
        func=action_generate_bcd
    )
    sub.add_parser(
        "full-setup",
        help="Run init, download-iso, generate-menu, and generate-bcd",
    ).set_defaults(func=action_full_setup)
    sub.add_parser(
        "verify-iso", help="Calculate and optionally verify the ISO hash"
    ).set_defaults(func=action_verify_iso)
    return parser


def main(argv: list[str] | None = None) -> int:
    parser = build_parser()
    args = parser.parse_args(argv)
    args.func(args)
    return 0


if __name__ == "__main__":
    sys.exit(main())
