"""Windows helper to stage Linux boot from NTFS.

This script is designed to be frozen with PyInstaller into an exe. It
focuses on the setup tasks that can be performed from an administrative
PowerShell or Command Prompt on Windows 10:

* Download a Linux ISO into a working directory on an NTFS partition.
* Generate a minimal ``menu.lst`` for grub4dos to loop-boot that ISO.
* Generate a ``.bat`` script that wires a grub4dos boot entry into BCD.

The script does not attempt to install a bootloader automatically.
Instead it produces the files and commands required so you can review
and run them with elevated privileges.
"""
from __future__ import annotations

import argparse
import hashlib
import sys
import textwrap
import urllib.request
from pathlib import Path

DEFAULT_ISO_URL = (
    "https://cdimage.debian.org/debian-cd/current/amd64/iso-dvd/debian-12.5.0-amd64-DVD-1.iso"
)
DEFAULT_ISO_NAME = "linux.iso"
DEFAULT_WORKDIR = Path.home() / "linux-install-helper"

MENU_TEMPLATE = """# Auto-generated by install_helper.py
# Copy this file to the root of the NTFS partition that hosts your ISO.
# Ensure grldr and grldr.mbr from grub4dos are also present in the same partition.

color blue/green yellow/black white/blue white/black

# Loop-boot the downloaded ISO. Adjust kernel parameters as needed.
title Boot Linux installer from ISO
find --set-root /{iso_name}
map /{iso_name} (hd32)
map --hook
chainloader (hd32)
boot
"""

BCD_BATCH_TEMPLATE = """@echo off
REM Auto-generated by install_helper.py
REM Run this from an elevated Command Prompt.

set WORKPART=%SystemDrive%
if NOT "%~1"=="" set WORKPART=%~1

bcdedit /create /d "Linux via grub4dos" /application BOOTSECTOR > tmp_guid.txt
for /f "tokens=1,2" %%a in (tmp_guid.txt) do if "%%a"=="The" set GUID=%%b
if "%GUID%"=="" for /f "tokens=2" %%a in (tmp_guid.txt) do set GUID=%%a

echo Created entry: %GUID%

bcdedit /set %GUID% device partition=%WORKPART%
bcdedit /set %GUID% path \grldr.mbr
bcdedit /displayorder %GUID% /addlast
bcdedit /timeout 5

del tmp_guid.txt

echo Done. Ensure grldr.mbr and menu.lst exist at %WORKPART%\
"""


def _require_twrp_hash(url: str, dest: Path, expected_sha256: str | None) -> None:
    """Enforce supplying a hash when dealing with TWRP-named images."""

    url_lower = url.lower()
    dest_lower = dest.name.lower()
    if ("twrp" in url_lower or "twrp" in dest_lower) and not expected_sha256:
        raise SystemExit(
            "Refusing to handle a TWRP-named image without --expected-sha256. "
            "Supply a vendor-published hash to avoid unofficial recoveries."
        )


def download_with_hash(url: str, dest: Path, expected_sha256: str | None = None) -> str:
    """Download *url* to *dest* while streaming SHA256 verification.

    The download is written to a ``.part`` file first so we never leave a
    half-written or unverified ISO behind. If *expected_sha256* is provided,
    the hash is compared before renaming into place. A mismatch aborts the
    download and removes the temporary file to guard against unofficial or
    tampered images.
    """

    dest.parent.mkdir(parents=True, exist_ok=True)
    tmp_dest = dest.with_name(dest.name + ".part")
    h = hashlib.sha256()

    _require_twrp_hash(url, dest, expected_sha256)

    with urllib.request.urlopen(url) as response, open(tmp_dest, "wb") as fh:
        for chunk in iter(lambda: response.read(128 * 1024), b""):
            h.update(chunk)
            fh.write(chunk)

    digest = h.hexdigest()
    if expected_sha256:
        expected = expected_sha256.lower()
        if digest.lower() != expected:
            tmp_dest.unlink(missing_ok=True)
            raise SystemExit(
                "SHA256 mismatch for downloaded ISO. "
                f"Expected {expected}, got {digest}. File removed."
            )

    tmp_dest.replace(dest)
    return digest


def sha256sum(path: Path) -> str:
    h = hashlib.sha256()
    with open(path, "rb") as fh:
        for chunk in iter(lambda: fh.read(128 * 1024), b""):
            h.update(chunk)
    return h.hexdigest()


def write_menu(workdir: Path, iso_name: str) -> Path:
    path = workdir / "menu.lst"
    path.write_text(MENU_TEMPLATE.format(iso_name=iso_name), encoding="utf-8")
    return path


def write_bcd_batch(workdir: Path) -> Path:
    path = workdir / "install-grub4dos.bat"
    path.write_text(BCD_BATCH_TEMPLATE, encoding="utf-8")
    return path


def action_init(args: argparse.Namespace) -> None:
    workdir = Path(args.workdir).expanduser()
    workdir.mkdir(parents=True, exist_ok=True)
    print(f"Initialized work directory at {workdir}")


def action_download_iso(args: argparse.Namespace) -> None:
    workdir = Path(args.workdir).expanduser()
    workdir.mkdir(parents=True, exist_ok=True)
    dest = workdir / args.iso_name
    _require_twrp_hash(args.url, dest, args.expected_sha256)
    if dest.exists() and not args.force:
        if "twrp" in dest.name.lower() and not args.expected_sha256:
            raise SystemExit(
                "TWRP-named image already exists but is unverified. "
                "Re-run with --expected-sha256 and --force to replace it with a hashed download."
            )
        print(f"ISO already exists at {dest}. Use --force to overwrite.")
        return
    print(f"Downloading {args.url} -> {dest}")
    digest = download_with_hash(args.url, dest, args.expected_sha256)
    print(f"Download complete. SHA256: {digest}")
    if args.expected_sha256:
        print("SHA256 matches expected value.")


def action_generate_menu(args: argparse.Namespace) -> None:
    workdir = Path(args.workdir).expanduser()
    workdir.mkdir(parents=True, exist_ok=True)
    path = write_menu(workdir, args.iso_name)
    print(f"menu.lst written to {path}")


def action_generate_bcd(args: argparse.Namespace) -> None:
    workdir = Path(args.workdir).expanduser()
    workdir.mkdir(parents=True, exist_ok=True)
    path = write_bcd_batch(workdir)
    print(f"BCD install script written to {path}")


def action_verify_iso(args: argparse.Namespace) -> None:
    workdir = Path(args.workdir).expanduser()
    iso_path = workdir / args.iso_name
    if not iso_path.is_file():
        raise SystemExit(f"ISO not found at {iso_path}. Use --workdir/--iso-name to point to it.")
    _require_twrp_hash("", iso_path, args.expected_sha256)
    digest = sha256sum(iso_path)
    print(f"SHA256 for {iso_path}: {digest}")
    if args.expected_sha256:
        expected = args.expected_sha256.lower()
        if digest.lower() != expected:
            raise SystemExit(
                f"Hash mismatch. Expected {expected}, got {digest}. Replace the ISO before booting."
            )
        print("SHA256 matches expected value.")


def action_full_setup(args: argparse.Namespace) -> None:
    workdir = Path(args.workdir).expanduser()
    action_init(args)
    args.url = args.url or DEFAULT_ISO_URL
    action_download_iso(args)
    action_generate_menu(args)
    action_generate_bcd(args)
    print(
        textwrap.dedent(
            f"""
            Next steps:
            1) Copy grldr and grldr.mbr from grub4dos into {workdir}.
            2) Review {workdir / 'menu.lst'} and adjust kernel parameters as needed.
            3) Run the generated install-grub4dos.bat from an elevated Command Prompt.
            4) Reboot and select the 'Linux via grub4dos' entry to start the installer.
            """
        ).strip()
    )


def build_parser() -> argparse.ArgumentParser:
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument(
        "--workdir",
        default=str(DEFAULT_WORKDIR),
        help="Directory on NTFS where ISO, menu.lst, and scripts should live.",
    )
    parser.add_argument("--iso-name", default=DEFAULT_ISO_NAME, help="Filename for the ISO")
    parser.add_argument("--url", default=DEFAULT_ISO_URL, help="Linux ISO URL")
    parser.add_argument("--force", action="store_true", help="Overwrite existing ISO")
    parser.add_argument(
        "--expected-sha256",
        help="Expected SHA256 hash for the ISO; verification happens after download or via verify-iso.",
    )

    sub = parser.add_subparsers(dest="command", required=True)
    sub.add_parser("init", help="Create the working directory").set_defaults(
        func=action_init
    )
    sub.add_parser("download-iso", help="Download the ISO").set_defaults(
        func=action_download_iso
    )
    sub.add_parser("generate-menu", help="Write grub4dos menu.lst").set_defaults(
        func=action_generate_menu
    )
    sub.add_parser("generate-bcd", help="Write BCD wiring batch script").set_defaults(
        func=action_generate_bcd
    )
    sub.add_parser(
        "verify-iso",
        help="Compute SHA256 for the ISO in the workdir and compare with --expected-sha256",
    ).set_defaults(func=action_verify_iso)
    sub.add_parser(
        "full-setup",
        help="Run init, download-iso, generate-menu, and generate-bcd",
    ).set_defaults(func=action_full_setup)
    return parser


def main(argv: list[str] | None = None) -> int:
    parser = build_parser()
    args = parser.parse_args(argv)
    args.func(args)
    return 0


if __name__ == "__main__":
    sys.exit(main())
